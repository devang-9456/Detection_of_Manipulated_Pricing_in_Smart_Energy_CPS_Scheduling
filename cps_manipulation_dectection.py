# -*- coding: utf-8 -*-
"""CPS manipulation dectection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19E_C12qWgcoX2WM-ITdrg2H0Typ35CCQ
"""

from google.colab import drive
drive.mount('/content/drive')

!pip install pulp

import numpy as np
from sklearn.model_selection import train_test_split
from sklearn import metrics
from sklearn import linear_model
from sklearn.preprocessing import MinMaxScaler
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis
import pandas as pd
from sklearn import svm
from sklearn.svm import SVC
from sklearn.metrics import classification_report, confusion_matrix
from pulp import *
import matplotlib.pyplot as plt

trainDF = pd.read_csv('/content/drive/MyDrive/COMP321720212022CW2A/TrainingData.txt', header=None)
y = trainDF[24].tolist()
trainDF = trainDF.drop(24, axis=1)
x = trainDF.values.tolist()

x = np.array(x)
y = np.array(y)
x_train_full = x
y_train_full = y

testDF = pd.read_csv('/content/drive/MyDrive/COMP321720212022CW2A/TestingData.txt', header=None)
x_classify = testDF.values.tolist()

x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=0)
print(len(x_train),len(x_test),len(y_train),len(y_test))

lda = LinearDiscriminantAnalysis()
lda.fit(x_train, y_train)
y_pred = lda.predict(x_classify)
y_pred = [int(x) for x in y_pred]
print(len(y_pred))
print("\nAccuracy for LDA classifier on full Training Dataset:",lda.score(x_train_full, y_train_full))

print("Testing accuracy for 25% of training data:",lda.score(x_test, y_test))
print("Training accuracy:",lda.score(x_train, y_train))
predDF = pd.DataFrame({'Prediction': y_pred})
testDF = testDF.join(predDF)
testDF.to_csv("/content/drive/MyDrive/COMP321720212022CW2A/TestingResults.txt", header=None, index=None)
predDF.to_csv("PredictionsOnly.txt", header=None, index=None)
print("\nPredictions in output file TestingResults.txt")

svclassifier = SVC(kernel='linear')
svclassifier.fit(x_train,y_train)
y_pred = svclassifier.predict(x_test)
print(list(y_pred))
print(confusion_matrix(y_test,y_pred))
print(classification_report(y_test,y_pred))
print("Accuracy:", metrics.accuracy_score(y_test,y_pred))

from sklearn.neighbors import KNeighborsClassifier

model = KNeighborsClassifier(n_neighbors=50)
model.fit(x_train,y_train)
predicted= model.predict(x_test)
print(predicted)
print(confusion_matrix(y_test,predicted))
print(classification_report(y_test,predicted))
print("Accuracy:", metrics.accuracy_score(y_test,predicted))

from sklearn.tree import DecisionTreeClassifier # Import Decision Tree Classifier
from sklearn.model_selection import train_test_split # Import train_test_split function
from sklearn import metrics #Import scikit-learn metrics module for accuracy calculation

clf = DecisionTreeClassifier(max_depth=5)
clf = clf.fit(x_train,y_train)
y_pred = clf.predict(x_test)
print("Accuracy:",metrics.accuracy_score(y_test, y_pred))

excelFile = pd.read_excel ('/content/drive/MyDrive/COMP321720212022CW2A/COMP3217CW2Input.xlsx', sheet_name = 'User & Task ID')
taskName = excelFile['User & Task ID'].tolist()
readyTime = excelFile['Ready Time'].tolist()
deadline = excelFile['Deadline'].tolist()
maxEnergyPerHour = excelFile['Maximum scheduled energy per hour'].tolist()
energyDemand = excelFile['Energy Demand'].tolist()
tasks = []
taskNames = []

for k in range (len(readyTime)):
    task = []
    task.append(readyTime[k])
    task.append(deadline[k])
    task.append(maxEnergyPerHour[k])
    task.append(energyDemand[k])
    taskNames.append(taskName[k])
    
    tasks.append(task)
          
#Reading Testing Data Output
testDF = pd.read_csv('/content/drive/MyDrive/COMP321720212022CW2A/TestingResults.txt', header=None)
y_labels = testDF[24].tolist()
testDF = testDF.drop(24, axis=1)
x_data = testDF.values.tolist()

def plot(model, count):
    hours = [str(x) for x in range(0, 24)]
    pos = np.arange(len(hours))
    users = ['user1', 'user2', 'user3', 'user4', 'user5']
    color_list = ['violet','mediumblue','red','yellow','grey']
    plot_list = []
    to_plot = []
    
    #Create lists to plot usage
    for user in users:
        temp_list = []
        for hour in hours:
            hour_list_temp = []
            task_count = 0
            for var in model.variables():
                if user == var.name.split('_')[0] and str(hour) == var.name.split('_')[2]:
                    task_count += 1
                    #print('{} {} {} {}'.format(user, hour, var, var.value()))
                    hour_list_temp.append(var.value())
            temp_list.append(sum(hour_list_temp))
        plot_list.append(temp_list)

    #Show as a bar chart stacked by user
    plt.bar(pos,plot_list[0],color=color_list[0],edgecolor='black',bottom=0)
    plt.bar(pos,plot_list[1],color=color_list[1],edgecolor='black',bottom=np.array(plot_list[0]))
    plt.bar(pos,plot_list[2],color=color_list[2],edgecolor='black',bottom=np.array(plot_list[0])+np.array(plot_list[1]))
    plt.bar(pos,plot_list[3],color=color_list[3],edgecolor='black',bottom=np.array(plot_list[0])+np.array(plot_list[1])+np.array(plot_list[2]))
    plt.bar(pos,plot_list[4],color=color_list[4],edgecolor='black',bottom=np.array(plot_list[0])+np.array(plot_list[1])+np.array(plot_list[2])+np.array(plot_list[3]))
    
    plt.xticks(pos, hours)
    plt.xlabel('Hour')
    plt.ylabel('Energy Usage (kW)')
    plt.title('Energy Usage Per Hour For All Users\nDay %i'%count)
    plt.legend(users,loc=0)
    image=plt.gcf()
    image.savefig('/content/drive/MyDrive/COMP321720212022CW2A/plots/'+str(count)+'.png')
    plt.show()
    plt.clf()

    return plot_list

answerlist=[]
for index, price_list in enumerate(x_data):
  if y_labels[index] == 1:
    vars = []
    c = []
    eq = []
    
    #create LP problem model for Minimization    
    model = LpProblem(name="scheduling-problem", sense=LpMinimize)
    
    #Loop through list of tasks
    for ind, task in enumerate(tasks):
        n = task[1] - task[0] + 1
        temp = []
        #Loop between ready_time and deadline for each task
        #Creates LP variables with given constraints and unique names
        for i in range(task[0], task[1] + 1):
            x = LpVariable(name=taskNames[ind]+'_'+str(i), lowBound=0, upBound=task[2])
            temp.append(x)
        vars.append(temp)

    #Create objective function for price (to minimize) and add to the model
    for i, task in enumerate(tasks):
        for var in vars[i]:
            price = price_list[int(var.name.split('_')[2])]
            c.append(price * var)
    model += lpSum(c)
              
    #Add additional constraints to the model      
    for i, task in enumerate(tasks):
        temp = []
        for var in vars[i]:
            temp.append(var)
        eq.append(temp)
        model += lpSum(temp) == task[3]
      
    answer = model.solve()
    answerlist.append(answer)
    plot(model,index+1)
    

#print(model)  
print(len(answerlist))

print(LpStatus[answer], value(model.objective))
#for var in model.variables():
  #print(var.name, '=' ,var.varValue)

for i in range(0,100):
  print("Day "+str(i+1)+":\t"+str(y_pred[i])+",")